# MERI é¡¹ç›®è¯¦ç»†è§£è¯»

## ğŸ“š ç›®å½•
1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [æ•´ä½“æ¶æ„](#æ•´ä½“æ¶æ„)
3. [æ ¸å¿ƒæµç¨‹](#æ ¸å¿ƒæµç¨‹)
4. [æ¨¡å—è¯¦è§£](#æ¨¡å—è¯¦è§£)
5. [ä»£ç é€è¡Œè§£æ](#ä»£ç é€è¡Œè§£æ)
6. [æ•°æ®æµè½¬](#æ•°æ®æµè½¬)
7. [å¦‚ä½•ä¿®æ”¹é¡¹ç›®](#å¦‚ä½•ä¿®æ”¹é¡¹ç›®)

---

## é¡¹ç›®æ¦‚è¿°

### é¡¹ç›®æ˜¯åšä»€ä¹ˆçš„ï¼Ÿ

**MERI** = **M**odality-aware **E**xtraction and **R**etrieval of **I**nformation

ç®€å•è¯´ï¼š**ä» PDF æ–‡æ¡£ä¸­è‡ªåŠ¨æå–ç»“æ„åŒ–ä¿¡æ¯**

### ä¸¾ä¸ªä¾‹å­

å‡è®¾ä½ æœ‰ä¸€ä¸ªäº§å“è¯´æ˜ä¹¦ PDFï¼Œé‡Œé¢æœ‰å¾ˆå¤šæŠ€æœ¯å‚æ•°ï¼š
- äº§å“åç§°ï¼šXXX å‹å·
- å‹åŠ›ï¼š100 bar
- æ¸©åº¦èŒƒå›´ï¼š-10Â°C åˆ° 50Â°C
- ä¿ä¿®æœŸï¼š2å¹´

**ä¼ ç»Ÿæ–¹å¼**ï¼šäººå·¥é˜…è¯»ï¼Œæ‰‹åŠ¨è¾“å…¥åˆ°ç³»ç»Ÿ
**MERI æ–¹å¼**ï¼šç»™ MERI ä¸€ä¸ª PDF + ä¸€ä¸ª JSON Schemaï¼ˆå®šä¹‰è¦æå–ä»€ä¹ˆï¼‰ï¼Œå®ƒè‡ªåŠ¨æå–å¹¶è¿”å›ç»“æ„åŒ–çš„ JSON æ•°æ®

### è¾“å…¥å’Œè¾“å‡º

**è¾“å…¥**ï¼š
1. PDF æ–‡ä»¶ï¼ˆåŒ…å«æ–‡æœ¬ã€è¡¨æ ¼ã€å›¾ç‰‡ï¼‰
2. JSON Schemaï¼ˆå®šä¹‰è¦æå–å“ªäº›å­—æ®µï¼Œæ ¼å¼æ˜¯ä»€ä¹ˆï¼‰

**è¾“å‡º**ï¼š
- å¡«å……å¥½çš„ JSON æ•°æ®ï¼ŒåŒ…å«ä» PDF ä¸­æå–çš„æ‰€æœ‰ä¿¡æ¯

---

## æ•´ä½“æ¶æ„

### é¡¹ç›®ç»“æ„ï¼ˆç®€åŒ–ç‰ˆï¼‰

```
MERI é¡¹ç›®
â”‚
â”œâ”€â”€ ç¬¬ä¸€æ­¥ï¼šPDF è§£æï¼ˆDoclingï¼‰
â”‚   â””â”€â”€ æŠŠ PDF è½¬æ¢æˆ HTML æ ¼å¼ï¼ˆåŒ…å«æ–‡æœ¬å’Œå›¾ç‰‡ï¼‰
â”‚
â”œâ”€â”€ ç¬¬äºŒæ­¥ï¼šæ ¼å¼å¤„ç†ï¼ˆFormat Handlerï¼‰
â”‚   â””â”€â”€ æŠŠ HTML åˆ‡åˆ†æˆå°å—ï¼ˆchunksï¼‰ï¼Œå‡†å¤‡å‘é€ç»™ AI
â”‚
â””â”€â”€ ç¬¬ä¸‰æ­¥ï¼šä¿¡æ¯æå–ï¼ˆExtractorï¼‰
    â””â”€â”€ ä½¿ç”¨å¤§æ¨¡å‹ä»æ¯ä¸ªå°å—ä¸­æå–ä¿¡æ¯ï¼Œåˆå¹¶æˆæœ€ç»ˆç»“æœ
```

### è¯¦ç»†ç›®å½•ç»“æ„

```
meri/
â”œâ”€â”€ meri.py                    # ä¸»å…¥å£ç±»
â”œâ”€â”€ intermediate_format/       # ä¸­é—´æ ¼å¼å¤„ç†
â”‚   â””â”€â”€ format_handler.py      # HTML æ ¼å¼å¤„ç†å™¨
â”œâ”€â”€ extraction/               # ä¿¡æ¯æå–
â”‚   â”œâ”€â”€ extractor.py          # æå–å™¨ä¸»ç±»
â”‚   â””â”€â”€ iterative_json_completion.py  # è¿­ä»£å¼ JSON å¡«å……
â”œâ”€â”€ prompts/                   # Prompt æ¨¡æ¿
â”‚   â””â”€â”€ prompts.py
â”œâ”€â”€ utils/                     # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ llm_utils.py          # å¤§æ¨¡å‹è°ƒç”¨å·¥å…·
â”‚   â””â”€â”€ docling_utils.py      # Docling å·¥å…·
â””â”€â”€ datamodels/               # æ•°æ®æ¨¡å‹
    â””â”€â”€ datamodels.py
```

---

## æ ¸å¿ƒæµç¨‹

### å®Œæ•´æµç¨‹å›¾

```
PDF æ–‡ä»¶
    â†“
[1. PDF è§£æ] Docling åº“
    â†“
HTML æ ¼å¼ï¼ˆæ–‡æœ¬ + å›¾ç‰‡çš„ base64ï¼‰
    â†“
[2. æ ¼å¼å¤„ç†] HTMLFormatHandler
    â†“
åˆ‡åˆ†æˆå¤šä¸ª chunksï¼ˆæ¯ä¸ª chunk åŒ…å«æ–‡æœ¬å’Œå›¾ç‰‡ï¼‰
    â†“
[3. ä¿¡æ¯æå–] JsonExtractor + IterativeJsonPopulator
    â†“
å¯¹æ¯ä¸ª chunk è°ƒç”¨å¤§æ¨¡å‹
    â†“
åˆå¹¶æ‰€æœ‰ç»“æœ
    â†“
æœ€ç»ˆ JSON æ•°æ®
```

### ä¸‰æ­¥è¯¦è§£

#### ç¬¬ä¸€æ­¥ï¼šPDF â†’ HTMLï¼ˆ`to_intermediate()`ï¼‰

**ç›®çš„**ï¼šæŠŠ PDF è½¬æ¢æˆ AI èƒ½ç†è§£çš„æ ¼å¼

**ä½¿ç”¨å·¥å…·**ï¼šDocling åº“
- è¯†åˆ« PDF ä¸­çš„æ–‡æœ¬ã€è¡¨æ ¼ã€å›¾ç‰‡
- è½¬æ¢æˆ HTML æ ¼å¼
- å›¾ç‰‡è½¬æ¢æˆ base64 ç¼–ç ï¼ˆå¯ä»¥ç›´æ¥åµŒå…¥åˆ°æ¶ˆæ¯ä¸­ï¼‰

**ä»£ç ä½ç½®**ï¼š`meri/meri.py` çš„ `to_intermediate()` æ–¹æ³•

#### ç¬¬äºŒæ­¥ï¼šHTML â†’ Chunksï¼ˆ`chunk()`ï¼‰

**ç›®çš„**ï¼šæŠŠå¤§çš„ HTML æ–‡æ¡£åˆ‡åˆ†æˆå°å—

**ä¸ºä»€ä¹ˆéœ€è¦åˆ‡åˆ†ï¼Ÿ**
- å¤§æ¨¡å‹æœ‰è¾“å…¥é•¿åº¦é™åˆ¶ï¼ˆtoken é™åˆ¶ï¼‰
- å¤§æ–‡æ¡£ä¸€æ¬¡æ€§å¤„ç†å¯èƒ½ä¸¢å¤±ä¿¡æ¯
- åˆ‡åˆ†åå¯ä»¥é€ä¸ªå¤„ç†ï¼Œæ›´å‡†ç¡®

**åˆ‡åˆ†ç­–ç•¥**ï¼š
- æŒ‰å­—ç¬¦æ•°åˆ‡åˆ†ï¼ˆé»˜è®¤ 450000 å­—ç¬¦ï¼‰
- ä¿ç•™é‡å éƒ¨åˆ†ï¼ˆoverlapï¼‰ï¼Œé¿å…ä¿¡æ¯ä¸¢å¤±
- åŒºåˆ†æ–‡æœ¬å’Œå›¾ç‰‡ï¼Œåˆ†åˆ«å¤„ç†

**ä»£ç ä½ç½®**ï¼š`meri/intermediate_format/format_handler.py` çš„ `chunk()` æ–¹æ³•

#### ç¬¬ä¸‰æ­¥ï¼šChunks â†’ JSONï¼ˆ`populate_schema()`ï¼‰

**ç›®çš„**ï¼šä»æ¯ä¸ª chunk ä¸­æå–ä¿¡æ¯ï¼Œå¡«å……åˆ° JSON Schema

**å·¥ä½œæ–¹å¼**ï¼š
1. å¯¹æ¯ä¸ª chunk è°ƒç”¨å¤§æ¨¡å‹
2. å¤§æ¨¡å‹åˆ†æ chunk å†…å®¹ï¼Œæå–ç¬¦åˆ Schema çš„ä¿¡æ¯
3. ä½¿ç”¨"å‡½æ•°è°ƒç”¨"ï¼ˆFunction Callingï¼‰ç¡®ä¿è¾“å‡ºæ ¼å¼æ­£ç¡®
4. å¤šè½®è¿­ä»£ï¼Œé€æ­¥å®Œå–„ç»“æœ

**ä»£ç ä½ç½®**ï¼š`meri/extraction/iterative_json_completion.py`

---

## æ¨¡å—è¯¦è§£

### 1. MERI ä¸»ç±»ï¼ˆ`meri/meri.py`ï¼‰

è¿™æ˜¯æ•´ä¸ªé¡¹ç›®çš„**å…¥å£ç±»**ï¼Œç”¨æˆ·ç›´æ¥ä½¿ç”¨å®ƒã€‚

#### åˆå§‹åŒ–ï¼ˆ`__init__`ï¼‰

```python
def __init__(self, pdf_path, chunks_max_characters=450000, 
             model='gpt-4o-mini', model_temp=0.0,
             do_ocr=False, do_cell_matching=True):
```

**å‚æ•°è¯´æ˜**ï¼š
- `pdf_path`ï¼šPDF æ–‡ä»¶è·¯å¾„
- `chunks_max_characters`ï¼šæ¯ä¸ª chunk çš„æœ€å¤§å­—ç¬¦æ•°ï¼ˆé»˜è®¤ 450000ï¼‰
- `model`ï¼šä½¿ç”¨çš„å¤§æ¨¡å‹åç§°ï¼ˆå¦‚ 'gpt-4o-mini'ï¼‰
- `model_temp`ï¼šæ¨¡å‹æ¸©åº¦ï¼ˆ0.0 = æ›´ç¡®å®šï¼Œ1.0 = æ›´éšæœºï¼‰
- `do_ocr`ï¼šæ˜¯å¦ä½¿ç”¨ OCRï¼ˆå…‰å­¦å­—ç¬¦è¯†åˆ«ï¼‰ï¼Œå¦‚æœ PDF æ˜¯æ‰«æä»¶éœ€è¦è®¾ä¸º True
- `do_cell_matching`ï¼šæ˜¯å¦è¿›è¡Œå•å…ƒæ ¼åŒ¹é…ï¼ˆæé«˜è¡¨æ ¼è¯†åˆ«å‡†ç¡®åº¦ï¼‰

**åˆå§‹åŒ–åšäº†ä»€ä¹ˆ**ï¼š
1. ä¿å­˜å‚æ•°
2. åˆ›å»º Docling çš„ DocumentConverterï¼ˆç”¨äº PDF è§£æï¼‰

#### æ ¸å¿ƒæ–¹æ³•

**`to_intermediate()`**ï¼šè½¬æ¢ PDF ä¸ºä¸­é—´æ ¼å¼
```python
def to_intermediate(self):
    # 1. ä½¿ç”¨ Docling è§£æ PDF
    self.docling_result = self.converter.convert(self.pdf_path)
    
    # 2. è½¬æ¢æˆ HTML æ ¼å¼
    self.int_format = export_to_html(self.docling_result.document)
    
    # 3. åˆ›å»ºæ ¼å¼å¤„ç†å™¨
    self.format_handler = HTMLFormatHandler(self.int_format)
```

**`run()`**ï¼šæ‰§è¡Œå®Œæ•´æµç¨‹
```python
def run(self, json_schema_str: str):
    # 1. å¦‚æœæ²¡æœ‰ä¸­é—´æ ¼å¼ï¼Œå…ˆè½¬æ¢
    if not self.format_handler:
        self.to_intermediate()
    
    # 2. åˆ›å»ºæå–å™¨
    self.jsonExtractor = JsonExtractor(
        intermediate_format=self.format_handler,
        chunks_max_characters=self.chunks_max_characters,
        model=self.model,
        model_temp=self.model_temp
    )
    
    # 3. æå–ä¿¡æ¯
    return self.jsonExtractor.populate_schema(json_schema_string=json_schema_str)
```

---

### 2. æ ¼å¼å¤„ç†å™¨ï¼ˆ`meri/intermediate_format/format_handler.py`ï¼‰

**ä½œç”¨**ï¼šå¤„ç† HTML æ ¼å¼çš„ä¸­é—´æ•°æ®ï¼Œå‡†å¤‡å‘é€ç»™å¤§æ¨¡å‹

#### HTMLFormatHandler ç±»

**æ ¸å¿ƒæ–¹æ³•**ï¼š

**`split()`**ï¼šæŒ‰åˆ†éš”ç¬¦åˆ‡åˆ† HTML
```python
def split(self) -> List[str]:
    return self.html_str.split('\n\n')  # æŒ‰åŒæ¢è¡Œç¬¦åˆ‡åˆ†
```

**`split_add_type()`**ï¼šåˆ‡åˆ†å¹¶æ ‡è®°ç±»å‹
```python
def split_add_type(self) -> List[Tuple[str, str]]:
    # è¿”å› [(ç±»å‹, HTMLå†…å®¹), ...]
    # ç±»å‹å¯èƒ½æ˜¯ 'text' æˆ– 'image'
```

**`chunk()`**ï¼šåˆ‡åˆ†æˆ chunks
```python
def chunk(self, character_threshold=1000, overlap=2):
    # 1. å…ˆåˆ‡åˆ†å¹¶æ ‡è®°ç±»å‹
    html_parts = self.split_add_type()
    
    # 2. æŒ‰å­—ç¬¦æ•°é˜ˆå€¼åˆ‡åˆ†æˆ chunks
    # 3. ä¿ç•™é‡å éƒ¨åˆ†ï¼ˆoverlapï¼‰
    # 4. è¿”å› List[List[Tuple[ç±»å‹, å†…å®¹]]]
```

**`prepare_gpt_message_content()`**ï¼šå‡†å¤‡å‘é€ç»™å¤§æ¨¡å‹çš„æ¶ˆæ¯æ ¼å¼
```python
def prepare_gpt_message_content(self, chunk):
    # æŠŠ chunk è½¬æ¢æˆ OpenAI API éœ€è¦çš„æ ¼å¼ï¼š
    # [
    #   {"type": "text", "text": "æ–‡æœ¬å†…å®¹"},
    #   {"type": "image_url", "image_url": {"url": "base64å›¾ç‰‡"}},
    #   ...
    # ]
```

---

### 3. æå–å™¨ï¼ˆ`meri/extraction/extractor.py`ï¼‰

**ä½œç”¨**ï¼šåè°ƒæ•´ä¸ªæå–è¿‡ç¨‹

#### JsonExtractor ç±»

**`populate_schema()`**ï¼šä¸»æå–æ–¹æ³•
```python
def populate_schema(self, json_schema_string: str):
    # 1. åˆ‡åˆ†æˆ chunks
    chunks = self.intermediate_format.chunk(...)
    
    # 2. å‡†å¤‡æ¶ˆæ¯å†…å®¹
    content_chunks = [
        self.intermediate_format.prepare_gpt_message_content(chunk) 
        for chunk in chunks
    ]
    
    # 3. åˆ›å»ºè¿­ä»£å¡«å……å™¨
    populator = IterativeJsonPopulator(
        json_schema_string,
        IterativePopulationStrategies.SELFSUPERVISED.value,
        ...
    )
    
    # 4. æ‰§è¡Œæå–
    results = populator.complete(content_chunks)
    return results
```

---

### 4. è¿­ä»£å¼ JSON å¡«å……ï¼ˆ`meri/extraction/iterative_json_completion.py`ï¼‰

**ä½œç”¨**ï¼šä½¿ç”¨å¤§æ¨¡å‹è¿­ä»£å¼åœ°å¡«å…… JSON Schema

#### ä¸‰ç§ç­–ç•¥

**ONE2ONE**ï¼šä¸€å¯¹ä¸€æå–
- æ¯ä¸ªå‚æ•°åªæå–ä¸€æ¬¡
- å¦‚æœåœ¨ä¸€ä¸ª chunk ä¸­æ‰¾åˆ°äº†ï¼Œå°±ä¸å†æ‰¾

**ONE2MANY**ï¼šä¸€å¯¹å¤šæå–
- æ¯ä¸ªå‚æ•°å¯ä»¥åœ¨å¤šä¸ªåœ°æ–¹æå–
- å…è®¸é‡å¤æå–

**SELFSUPERVISED**ï¼šè‡ªç›‘ç£æå–ï¼ˆé»˜è®¤ï¼‰
- æ¨¡å‹å¯ä»¥çœ‹åˆ°å·²ç»æå–çš„æ•°æ®
- æ¨¡å‹å¯ä»¥è‡ªå·±åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°æˆ–ä¿®æ­£

#### IterativeJsonPopulator ç±»

**`process_completion()`**ï¼šå¤„ç†ä¸€æ¬¡å¤§æ¨¡å‹è°ƒç”¨
```python
def process_completion(self, messages, populated_dict, tools=None):
    # 1. ç”Ÿæˆ promptï¼ˆåŒ…å«å·²æå–çš„æ•°æ®ï¼‰
    prompt = generate_self_supervised_json_population_prompt(populated_dict)
    
    # 2. å‡†å¤‡æ¶ˆæ¯
    messages = [{"role": "user", "content": [{"type": "text", "text": prompt}] + messages}]
    
    # 3. è°ƒç”¨å¤§æ¨¡å‹
    chat_response = chat_completion_request(
        messages=messages,
        tools=tools,  # å‡½æ•°å®šä¹‰ï¼ˆJSON Schemaï¼‰
        tool_choice={"type": "function", "function": {"name": "populate_json_schema"}},
        ...
    )
    
    # 4. ä»å‡½æ•°è°ƒç”¨ä¸­æå– JSON
    tool_calls = chat_response.choices[0].message.tool_calls
    return json.loads(tool_calls[0].function.arguments)
```

**`selfsupervised_completion()`**ï¼šè‡ªç›‘ç£ç­–ç•¥çš„å®ç°
```python
def selfsupervised_completion(self, content_chunks):
    populated_dict = {}  # å­˜å‚¨å·²æå–çš„æ•°æ®
    
    # åˆ›å»ºå‡½æ•°å®šä¹‰ï¼ˆtoolsï¼‰
    tools = create_openai_tools_arr(
        'populate_json_schema',
        'populate a json schema',
        json.loads(self.json_schema_str)
    )
    
    # å¤šè½®è¿­ä»£
    for i in range(self.n_rounds):
        # å¯¹æ¯ä¸ª chunk å¤„ç†
        for c_chunk in content_chunks:
            # æ›´æ–° populated_dict
            populated_dict = self.process_completion(
                c_chunk, 
                populated_dict,  # ä¼ å…¥å·²æå–çš„æ•°æ®
                tools=tools
            )
    
    return populated_dict
```

---

### 5. Prompt æ¨¡æ¿ï¼ˆ`meri/prompts/prompts.py`ï¼‰

**ä½œç”¨**ï¼šç”Ÿæˆå‘é€ç»™å¤§æ¨¡å‹çš„æç¤ºè¯

#### è‡ªç›‘ç£ç­–ç•¥çš„ Prompt

```python
SELFSUPERVISED_SCHEMA_POPULATION_TMPL = Template("""
    Context:
        - You are an expert system trained to understand and process technical information from documents.
        - Avoid false extractions by only extracting information where you are 99 percent confident in its accuracy.
    
    Task:
        - You will be provided with:
            - The document as a list of html elements
            - A dictionary ({{ some_dict }}) containing previously extracted information
            - You are required to extract specific data points from the provided markdown snippet.
    
    Data Representation:
        - Extracted numeric values will be separated from their units.
        - If the datapoint is only a string and does not have a unit:
            - use the string as the value
            - use None/null for the unit
        - Convert units if needed (e.g., mm to cm)
    
    Guidelines:
        - Minimize false extractions. Only extract information where you are 99 percent confident that it is correct.
        - extracting the "value" might require simple computation based on the "text". e.g. if text is "3+4" the value should be 7.
    
    Output:
        Return the extracted data in JSON format and pay attention to the provided json schema.
""")
```

**å…³é”®ç‚¹**ï¼š
- å‘Šè¯‰æ¨¡å‹è¦åšä»€ä¹ˆï¼ˆæå–ä¿¡æ¯ï¼‰
- å‘Šè¯‰æ¨¡å‹æ•°æ®æ ¼å¼ï¼ˆæ•°å€¼å’Œå•ä½åˆ†ç¦»ï¼‰
- å‘Šè¯‰æ¨¡å‹è¦è°¨æ…ï¼ˆ99% ç¡®ä¿¡æ‰æå–ï¼‰
- å‘Šè¯‰æ¨¡å‹å¦‚ä½•å¤„ç†å•ä½è½¬æ¢

---

### 6. å¤§æ¨¡å‹å·¥å…·ï¼ˆ`meri/utils/llm_utils.py`ï¼‰

**ä½œç”¨**ï¼šå°è£…å¤§æ¨¡å‹ API è°ƒç”¨

#### `chat_completion_request()` å‡½æ•°

```python
def chat_completion_request(messages, tools=None, tool_choice=None, 
                           response_format=None, model="gpt-4o-mini", ...):
    response = completion(
        model=model,
        messages=messages,      # æ¶ˆæ¯å†…å®¹ï¼ˆæ–‡æœ¬+å›¾ç‰‡ï¼‰
        tools=tools,             # å‡½æ•°å®šä¹‰
        tool_choice=tool_choice, # å¼ºåˆ¶è°ƒç”¨å‡½æ•°
        response_format=response_format,
        max_tokens=4096,
        temperature=temp,
    )
    return response
```

**ä½¿ç”¨ LiteLLM**ï¼š
- ç»Ÿä¸€æ¥å£ï¼Œæ”¯æŒå¤šç§å¤§æ¨¡å‹ï¼ˆOpenAIã€Geminiã€Hugging Face ç­‰ï¼‰
- åªéœ€è¦æ”¹æ¨¡å‹åç§°ï¼Œä»£ç ä¸éœ€è¦æ”¹

---

## ä»£ç é€è¡Œè§£æ

### ç¤ºä¾‹ï¼šå®Œæ•´ä½¿ç”¨æµç¨‹

```python
from meri import MERI
import json

# 1. åŠ è½½ JSON Schema
with open('schema.json') as f:
    schema = json.load(f)

# 2. åˆ›å»º MERI å®ä¾‹
meri = MERI(
    pdf_path='document.pdf',
    model='gpt-4o-mini',
    model_temp=0.0
)

# 3. æ‰§è¡Œæå–
result = meri.run(json.dumps(schema))

# 4. æŸ¥çœ‹ç»“æœ
print(json.dumps(result, indent=2, ensure_ascii=False))
```

### å†…éƒ¨æ‰§è¡Œæµç¨‹ï¼ˆè¯¦ç»†ï¼‰

#### æ­¥éª¤ 1ï¼šåˆå§‹åŒ– MERI

```python
meri = MERI(pdf_path='document.pdf', model='gpt-4o-mini')
```

**å†…éƒ¨æ‰§è¡Œ**ï¼š
1. ä¿å­˜ `pdf_path` å’Œ `model` ç­‰å‚æ•°
2. åˆ›å»º `DocumentConverter`ï¼ˆDocling çš„è½¬æ¢å™¨ï¼‰
3. `format_handler` è®¾ä¸º `None`ï¼ˆè¿˜æ²¡è½¬æ¢ï¼‰

#### æ­¥éª¤ 2ï¼šè°ƒç”¨ `run()`

```python
result = meri.run(json.dumps(schema))
```

**å†…éƒ¨æ‰§è¡Œ**ï¼š

**2.1 æ£€æŸ¥æ˜¯å¦éœ€è¦è½¬æ¢**
```python
if not self.format_handler:
    self.to_intermediate()  # è½¬æ¢ PDF
```

**2.2 è½¬æ¢ PDFï¼ˆ`to_intermediate()`ï¼‰**
```python
# 2.2.1 ä½¿ç”¨ Docling è§£æ PDF
self.docling_result = self.converter.convert(self.pdf_path)
# ç»“æœï¼šåŒ…å«æ–‡æœ¬ã€è¡¨æ ¼ã€å›¾ç‰‡çš„ç»“æ„åŒ–æ•°æ®

# 2.2.2 è½¬æ¢æˆ HTML
self.int_format = export_to_html(self.docling_result.document)
# ç»“æœï¼šHTML å­—ç¬¦ä¸²ï¼ŒåŒ…å«æ–‡æœ¬å’Œ base64 å›¾ç‰‡

# 2.2.3 åˆ›å»ºæ ¼å¼å¤„ç†å™¨
self.format_handler = HTMLFormatHandler(self.int_format)
```

**2.3 åˆ›å»ºæå–å™¨**
```python
self.jsonExtractor = JsonExtractor(
    intermediate_format=self.format_handler,
    chunks_max_characters=450000,
    model='gpt-4o-mini',
    model_temp=0.0
)
```

**2.4 æ‰§è¡Œæå–ï¼ˆ`populate_schema()`ï¼‰**

**2.4.1 åˆ‡åˆ†æˆ chunks**
```python
chunks = self.intermediate_format.chunk(
    character_threshold=450000,
    overlap=1
)
# ç»“æœï¼š[[(ç±»å‹, å†…å®¹), ...], ...]  # å¤šä¸ª chunks
```

**2.4.2 å‡†å¤‡æ¶ˆæ¯å†…å®¹**
```python
content_chunks = [
    self.intermediate_format.prepare_gpt_message_content(chunk)
    for chunk in chunks
]
# ç»“æœï¼š[[{"type": "text", "text": "..."}, {"type": "image_url", ...}], ...]
```

**2.4.3 åˆ›å»ºå¡«å……å™¨å¹¶æ‰§è¡Œ**
```python
populator = IterativeJsonPopulator(
    json_schema_string,
    'selfsupervised',  # ç­–ç•¥
    n_rounds=1,
    model='gpt-4o-mini',
    temp=0.0
)

results = populator.complete(content_chunks)
```

**2.4.4 è¿­ä»£å¡«å……ï¼ˆ`selfsupervised_completion()`ï¼‰**
```python
populated_dict = {}  # å­˜å‚¨ç»“æœ

# åˆ›å»ºå‡½æ•°å®šä¹‰
tools = [{
    "type": "function",
    "function": {
        "name": "populate_json_schema",
        "parameters": json_schema  # æ‚¨çš„ Schema
    }
}]

# å¤šè½®è¿­ä»£ï¼ˆé»˜è®¤ 1 è½®ï¼‰
for i in range(n_rounds):
    # å¯¹æ¯ä¸ª chunk å¤„ç†
    for c_chunk in content_chunks:
        # è°ƒç”¨å¤§æ¨¡å‹
        populated_dict = self.process_completion(
            c_chunk,           # å½“å‰ chunk çš„å†…å®¹
            populated_dict,    # å·²æå–çš„æ•°æ®
            tools=tools        # å‡½æ•°å®šä¹‰
        )
```

**2.4.5 å•æ¬¡å¤„ç†ï¼ˆ`process_completion()`ï¼‰**
```python
# 1. ç”Ÿæˆ promptï¼ˆåŒ…å«å·²æå–çš„æ•°æ®ï¼‰
prompt = generate_self_supervised_json_population_prompt(populated_dict)

# 2. å‡†å¤‡æ¶ˆæ¯
messages = [{
    "role": "user",
    "content": [
        {"type": "text", "text": prompt},  # Prompt
        ...c_chunk...  # Chunk å†…å®¹ï¼ˆæ–‡æœ¬+å›¾ç‰‡ï¼‰
    ]
}]

# 3. è°ƒç”¨å¤§æ¨¡å‹
chat_response = chat_completion_request(
    messages=messages,
    tools=tools,
    tool_choice={"type": "function", "function": {"name": "populate_json_schema"}},
    model='gpt-4o-mini',
    temp=0.0
)

# 4. æå– JSON
tool_calls = chat_response.choices[0].message.tool_calls
json_data = json.loads(tool_calls[0].function.arguments)

# 5. è¿”å›ï¼ˆä¼šåˆå¹¶åˆ° populated_dictï¼‰
return json_data
```

---

## æ•°æ®æµè½¬

### æ•°æ®æ ¼å¼å˜åŒ–

```
1. PDF æ–‡ä»¶ï¼ˆäºŒè¿›åˆ¶ï¼‰
   â†“
2. Docling ç»“æœï¼ˆPython å¯¹è±¡ï¼‰
   - åŒ…å«æ–‡æœ¬ã€è¡¨æ ¼ã€å›¾ç‰‡çš„ä½ç½®ä¿¡æ¯
   â†“
3. HTML å­—ç¬¦ä¸²
   - æ–‡æœ¬ï¼šHTML æ ‡ç­¾åŒ…è£¹
   - å›¾ç‰‡ï¼šbase64 ç¼–ç çš„ <img> æ ‡ç­¾
   â†“
4. Chunksï¼ˆåˆ—è¡¨çš„åˆ—è¡¨ï¼‰
   - å¤–å±‚åˆ—è¡¨ï¼šå¤šä¸ª chunks
   - å†…å±‚åˆ—è¡¨ï¼šæ¯ä¸ª chunk çš„å†…å®¹
   - æ¯ä¸ªå…ƒç´ ï¼š(ç±»å‹, HTMLå†…å®¹)
   â†“
5. æ¶ˆæ¯å†…å®¹ï¼ˆOpenAI æ ¼å¼ï¼‰
   - [{"type": "text", "text": "..."}, {"type": "image_url", ...}]
   â†“
6. å¤§æ¨¡å‹å“åº”
   - å‡½æ•°è°ƒç”¨çš„å‚æ•°ï¼ˆJSON å­—ç¬¦ä¸²ï¼‰
   â†“
7. æœ€ç»ˆ JSONï¼ˆPython å­—å…¸ï¼‰
   - ç¬¦åˆ Schema çš„ç»“æ„åŒ–æ•°æ®
```

### å…³é”®æ•°æ®ç»“æ„

#### JSON Schema ç¤ºä¾‹

```json
{
  "type": "object",
  "properties": {
    "title": {
      "type": "object",
      "properties": {
        "text": {"type": "string"},
        "bbox": {"type": "array"},
        "pageIndex": {"type": "integer"}
      }
    },
    "technicalSpecifications": {
      "type": "object",
      "properties": {
        "PRESSURE": {
          "label": "Pressure",
          "desiredUnit": "bar",
          "type": "object",
          "properties": {
            "parameter_properties": {
              "type": "object",
              "properties": {
                "value": {"type": "number"},
                "text": {"type": "string"},
                "unit": {"type": "string"},
                "bbox": {"type": "array"},
                "pageIndex": {"type": "integer"}
              }
            }
          }
        }
      }
    }
  }
}
```

#### æå–ç»“æœç¤ºä¾‹

```json
{
  "title": {
    "text": "Alfa Laval LKH",
    "bbox": [100, 200, 300, 250],
    "pageIndex": 0
  },
  "technicalSpecifications": {
    "PRESSURE": {
      "parameter_properties": {
        "value": 100,
        "text": "100 bar",
        "unit": "bar",
        "bbox": [150, 300, 200, 320],
        "pageIndex": 0
      }
    }
  },
  "notFoundList": ["TEMPERATURE_RANGE"]
}
```

---

## å¦‚ä½•ä¿®æ”¹é¡¹ç›®

### å¸¸è§ä¿®æ”¹åœºæ™¯

#### 1. ä¿®æ”¹æå–ç­–ç•¥

**ä½ç½®**ï¼š`meri/extraction/iterative_json_completion.py`

**å½“å‰ä½¿ç”¨**ï¼š`SELFSUPERVISED`ï¼ˆè‡ªç›‘ç£ï¼‰

**æ”¹ä¸ºå…¶ä»–ç­–ç•¥**ï¼š
```python
# åœ¨ extractor.py ä¸­
populator = IterativeJsonPopulator(
    json_schema_string,
    IterativePopulationStrategies.ONE2ONE.value,  # æ”¹ä¸º ONE2ONE
    ...
)
```

#### 2. ä¿®æ”¹ Prompt

**ä½ç½®**ï¼š`meri/prompts/prompts.py`

**ä¿®æ”¹æ¨¡æ¿**ï¼š
```python
SELFSUPERVISED_SCHEMA_POPULATION_TMPL = Template("""
    ä½ çš„æ–° prompt å†…å®¹...
""")
```

#### 3. ä¿®æ”¹ Chunk å¤§å°

**ä½ç½®**ï¼šåˆ›å»º MERI å®ä¾‹æ—¶
```python
meri = MERI(
    pdf_path='document.pdf',
    chunks_max_characters=200000,  # æ”¹å°ä¸€ç‚¹
    ...
)
```

#### 4. ä¿®æ”¹å¤§æ¨¡å‹

**ä½ç½®**ï¼šåˆ›å»º MERI å®ä¾‹æ—¶
```python
meri = MERI(
    pdf_path='document.pdf',
    model='huggingface/Qwen/Qwen2-VL-2B-Instruct',  # æ”¹ç”¨å…¶ä»–æ¨¡å‹
    ...
)
```

#### 5. æ·»åŠ æ–°çš„æå–ç­–ç•¥

**ä½ç½®**ï¼š`meri/extraction/iterative_json_completion.py`

**æ­¥éª¤**ï¼š
1. åœ¨ `IterativePopulationStrategies` æšä¸¾ä¸­æ·»åŠ æ–°ç­–ç•¥
2. åœ¨ `IterativeJsonPopulator` ç±»ä¸­æ·»åŠ å¯¹åº”çš„æ–¹æ³•
3. åœ¨ `complete()` æ–¹æ³•ä¸­æ·»åŠ æ˜ å°„

#### 6. ä¿®æ”¹è¾“å‡ºæ ¼å¼

**ä½ç½®**ï¼š`meri/extraction/iterative_json_completion.py` çš„ `process_completion()` æ–¹æ³•

**å¦‚æœæ¨¡å‹ä¸æ”¯æŒå‡½æ•°è°ƒç”¨**ï¼š
```python
# å½“å‰ä»£ç ï¼ˆä½¿ç”¨å‡½æ•°è°ƒç”¨ï¼‰
tool_calls = chat_response.choices[0].message.tool_calls
return json.loads(tool_calls[0].function.arguments)

# æ”¹ä¸ºç›´æ¥è§£æ JSONï¼ˆå¦‚æœæ¨¡å‹ä¸æ”¯æŒå‡½æ•°è°ƒç”¨ï¼‰
response_text = chat_response.choices[0].message.content
return json.loads(response_text)
```

---

## æ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µ

1. **ä¸¤æ­¥æ³•**ï¼šPDF â†’ HTML â†’ JSON
2. **åˆ†å—å¤„ç†**ï¼šå¤§æ–‡æ¡£åˆ‡åˆ†æˆå°å—
3. **è¿­ä»£æå–**ï¼šå¤šè½®å¤„ç†ï¼Œé€æ­¥å®Œå–„
4. **å‡½æ•°è°ƒç”¨**ï¼šç¡®ä¿è¾“å‡ºæ ¼å¼æ­£ç¡®

### å…³é”®æ–‡ä»¶

- `meri/meri.py`ï¼šå…¥å£ç±»
- `meri/intermediate_format/format_handler.py`ï¼šæ ¼å¼å¤„ç†
- `meri/extraction/iterative_json_completion.py`ï¼šæ ¸å¿ƒæå–é€»è¾‘
- `meri/prompts/prompts.py`ï¼šPrompt æ¨¡æ¿

### å­¦ä¹ å»ºè®®

1. **å…ˆè¿è¡Œç¤ºä¾‹**ï¼šä½¿ç”¨ `test_meri.py` çœ‹æ•ˆæœ
2. **ç†è§£æ•°æ®æµ**ï¼šè·Ÿè¸ªä¸€ä¸ª PDF ä»è¾“å…¥åˆ°è¾“å‡ºçš„å®Œæ•´è¿‡ç¨‹
3. **ä¿®æ”¹å°åŠŸèƒ½**ï¼šå…ˆæ”¹ Promptï¼Œçœ‹æ•ˆæœå˜åŒ–
4. **é€æ­¥æ·±å…¥**ï¼šç†è§£æ¯ä¸ªæ¨¡å—çš„ä½œç”¨åå†ä¿®æ”¹æ ¸å¿ƒé€»è¾‘

---

**ç¥æ‚¨å­¦ä¹ é¡ºåˆ©ï¼å¦‚æœ‰é—®é¢˜ï¼Œå¯ä»¥éšæ—¶æé—®ã€‚**




