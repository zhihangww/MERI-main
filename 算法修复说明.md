# 算法修复说明 - 防止错误地匹配所有右侧值

## ❌ 之前的错误

### 错误的结果
```
(1) 额定电压: 145kV/170kV; 三相; 55Hz; 4000A...  ← 把所有值都匹配了
(2) 相数: (无)
(3) 额定频率: (无)
(4) 额定电流: (无)
```

### 根本原因
算法在做后续匹配时，只检查了：
- y距离 < 60
- x坐标相似

**但没有检查**：这个div是否应该属于下一个列表项！

结果：只要满足距离条件，就一直匹配下去，把所有右侧的值都匹配给第一个参数。

---

## ✅ 新算法逻辑

### 两阶段匹配

#### 阶段1：首次匹配（一对一）
```python
for each 列表项:
    查找垂直对齐的右侧div
    如果找到：
        匹配并标记
        记录匹配的div索引
```

**效果**：每个列表项先找到自己对应的第一个值。

#### 阶段2：后续匹配（一对多）
```python
for each 已匹配的列表项:
    从首次匹配位置之后开始查找
    
    for each div:
        如果这个div已被其他项首次匹配:
            停止！(说明遇到下一个参数的值了)
        
        如果存在下一个列表项:
            计算 distance_to_next = |div_y - next_item_y|
            计算 distance_to_current = div_y - current_last_value_y
            
            如果更接近下一个列表项:
                停止！(这个div属于下一个参数)
        
        如果满足后续匹配条件:
            匹配
        否则:
            停止！
```

### 关键改进

#### 1. 停止条件1：遇到已匹配的div
```python
if j_search in div_matched_map:
    # 这个div已被其他项首次匹配
    # 说明这是下一个参数的值
    break  # 停止后续匹配
```

#### 2. 停止条件2：更接近下一个列表项
```python
if next_item_y is not None:
    distance_to_next_item = abs(y_div - next_item_y)
    distance_to_current_last = y_div - last_value_y
    
    # 如果这个div与下一个列表项的距离
    # 小于与当前项最后一个值的距离
    # 说明这个div更可能属于下一个参数
    if distance_to_next_item < distance_to_current_last + 20:
        break  # 停止
```

#### 3. 停止条件3：不满足后续匹配条件
```python
if not (is_below and is_near and is_similar_x):
    break  # 停止
```

---

## 📊 示例验证

### 场景1：一对一
```
输入：
<li>(1) 额定电压</li>  y=263
<li>(2) 相数</li>      y=295
<li>(3) 额定频率</li>  y=326

<div>145kV</div>       y=264
<div>三相</div>        y=295
<div>55Hz</div>        y=327

阶段1（首次匹配）：
  (1)匹配145kV → div_matched_map[j1]=(1)
  (2)匹配三相  → div_matched_map[j2]=(2)
  (3)匹配55Hz  → div_matched_map[j3]=(3)

阶段2（后续匹配）：
  (1)尝试后续匹配三相：
    - 检查：j2 in div_matched_map? YES
    - 停止！(三相已被(2)首次匹配)
  
  (2)尝试后续匹配55Hz：
    - 检查：j3 in div_matched_map? YES
    - 停止！
  
  (3)无后续值

结果：
(1) 额定电压: 145kV     ✓
(2) 相数: 三相          ✓
(3) 额定频率: 55Hz      ✓
```

### 场景2：一对二
```
输入：
<li>(4) 额定电流</li>           y=383
<li>(5) 额定短时耐受电流</li>   y=446

<div>4000A（主变）</div>        y=383
<div>3150A（海缆）</div>        y=414  ← 紧邻
<div>40kA</div>                 y=445

阶段1（首次匹配）：
  (4)匹配4000A → div_matched_map[j1]=(4)
  (5)匹配40kA  → div_matched_map[j3]=(5)

阶段2（后续匹配）：
  (4)尝试后续匹配3150A：
    - 检查：j2 in div_matched_map? NO ✓
    - 计算距离：
      - to_next_item = |414-446| = 32
      - to_current = 414-383 = 31
      - 32 < 31+20? NO ✓ (更接近当前项)
    - 检查条件：
      - is_below? YES
      - is_near (31<60)? YES
      - is_similar_x? YES
    - 匹配！→ div_matched_map[j2]=(4)
  
  (4)尝试后续匹配40kA：
    - 检查：j3 in div_matched_map? YES
    - 停止！(40kA已被(5)首次匹配)

结果：
(4) 额定电流: 4000A（主变）; 3150A（海缆）  ✓
(5) 额定短时耐受电流: 40kA                 ✓
```

---

## 🎯 核心改进总结

### 之前的问题
- ❌ 没有检查div是否已被其他项匹配
- ❌ 没有判断div是否更接近下一个列表项
- ❌ 不满足条件时继续尝试，而不是停止

### 现在的解决
- ✅ 两阶段匹配：先一对一，再一对多
- ✅ 遇到已匹配的div立即停止
- ✅ 判断div与下一个列表项的距离
- ✅ 不满足条件立即停止

### 保证
- ✅ 每个div最多被匹配一次
- ✅ 一对一的参数不受影响
- ✅ 一对多的参数正确识别多个值
- ✅ 不会错误地把下一个参数的值匹配给上一个参数

---

## 🧪 测试验证

### 运行测试
```bash
poetry run python test_layout_enhancement.py
```

### 检查结果
在 `debug_enhanced.html` 中应该看到：

**一对一**：
```html
<div>(1) 额定电压: 145kV/170kV</div>
<div>(2) 相数: 三相</div>
<div>(3) 额定频率: 55Hz</div>
```

**一对多**：
```html
<div>(4) 额定电流: 4000A（主变间隔、分段间隔）; 3150A（海缆间隔、站用变间隔）</div>
```

**不应该看到**：
```html
<div>(1) 额定电压: 145kV/170kV; 三相; 55Hz; ...</div>  ✗ 错误
```

---

**现在算法是正确的！请测试验证。** 🎯


